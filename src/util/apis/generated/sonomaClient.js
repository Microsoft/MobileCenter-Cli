/*
 * Code generated by Microsoft (R) AutoRest Code Generator 0.16.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var ServiceClient = msRest.ServiceClient;
var WebResource = msRest.WebResource;

var models = require('./models');
var operations = require('./operations');

/**
 * @class
 * Initializes a new instance of the SonomaClient class.
 * @constructor
 *
 * @param {string} appName - The name of the application
 *
 * @param {string} ownerName - The name of the owner
 *
 * @param {number} buildId - The build ID
 *
 * @param {string} branch - The branch name
 *
 * @param {string} sha - The SHA hash
 *
 * @param {string} symbolUploadId - The ID of the symbol upload
 *
 * @param {string} symbolId - The ID of the symbol (uuid of the symbol)
 *
 * @param {string} crashGroupId - id of a specific group
 *
 * @param {string} crashId - id of a specific error
 *
 * @param {date} start - Start date time in data in ISO 8601 date time format
 *
 * @param {string} interval - Size of interval in ISO 8601 duration format. (PnYnMnDTnHnMnS|PnW|P<date>T<time>). The valid durations are 1 day (P1D), 1 week (P1W), and 30 days (P30D).
 *
 * @param {credentials} credentials - Subscription credentials which uniquely identify client subscription.
 *
 * @param {string} [baseUri] - The base URI of the service.
 *
 * @param {object} [options] - The parameter options
 *
 * @param {Array} [options.filters] - Filters to be added to the request pipeline
 *
 * @param {object} [options.requestOptions] - Options for the underlying request object
 * {@link https://github.com/request/request#requestoptions-callback Options doc}
 *
 * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
 *
 * @param {string} [options.form] - The selected form of the object. Possible values include: 'lite', 'full'
 *
 * @param {string} [options.appVersion] - version
 *
 * @param {date} [options.dateFrom] - 
 *
 * @param {date} [options.dateTo] - 
 *
 * @param {date} [options.lastOccurrenceFrom] - Earliest date when the last time a crash occured in a error group
 *
 * @param {date} [options.lastOccurrenceTo] - Latest date when the last time a crash occured in a error group
 *
 * @param {string} [options.errorType] - Possible values include: 'something', 'else'
 *
 * @param {string} [options.groupType] - Possible values include: 'GroupType1', 'GroupType2'
 *
 * @param {string} [options.groupStatus] - Possible values include: 'Open', 'Closed', 'Ignored'
 *
 * @param {boolean} [options.includeReport] - true if the error should include the raw error report. Default is false
 *
 * @param {boolean} [options.includeLog] - true if the error should include the custom log report. Default is false
 *
 * @param {string} [options.groupTextSearch] - A freetext search that matches in error, error types, error stack_traces and error user
 *
 * @param {date} [options.end] - Last date time in data in ISO 8601 date time format.
 *
 * @param {array} [options.versions] - 
 *
 * @param {number} [options.count] - The number of results to return
 *
 * @param {number} [options.top] - The maximum number of results to return.
 *
 * @param {number} [options.skip] - The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.
 *
 * @param {string} [options.filter] - A filter as specified in https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#97-filtering.
 *
 * @param {string} [options.inlinecount] - Controls whether or not to include a count of all the items accross all pages. Possible values include: 'allpages', 'none'
 *
 */
function SonomaClient(appName, ownerName, buildId, branch, sha, symbolUploadId, symbolId, crashGroupId, crashId, start, interval, credentials, baseUri, options) {
  this.includeReport = false;
  this.includeLog = false;
  this.top = 30;
  this.skip = 0;
  this.inlinecount = 'none';
  if (appName === null || appName === undefined) {
    throw new Error('\'appName\' cannot be null.');
  }
  if (ownerName === null || ownerName === undefined) {
    throw new Error('\'ownerName\' cannot be null.');
  }
  if (buildId === null || buildId === undefined) {
    throw new Error('\'buildId\' cannot be null.');
  }
  if (branch === null || branch === undefined) {
    throw new Error('\'branch\' cannot be null.');
  }
  if (sha === null || sha === undefined) {
    throw new Error('\'sha\' cannot be null.');
  }
  if (symbolUploadId === null || symbolUploadId === undefined) {
    throw new Error('\'symbolUploadId\' cannot be null.');
  }
  if (symbolId === null || symbolId === undefined) {
    throw new Error('\'symbolId\' cannot be null.');
  }
  if (crashGroupId === null || crashGroupId === undefined) {
    throw new Error('\'crashGroupId\' cannot be null.');
  }
  if (crashId === null || crashId === undefined) {
    throw new Error('\'crashId\' cannot be null.');
  }
  if (start === null || start === undefined) {
    throw new Error('\'start\' cannot be null.');
  }
  if (interval === null || interval === undefined) {
    throw new Error('\'interval\' cannot be null.');
  }
  if (credentials === null || credentials === undefined) {
    throw new Error('\'credentials\' cannot be null.');
  }

  if (!options) options = {};

  SonomaClient['super_'].call(this, credentials, options);
  this.baseUri = baseUri;
  if (!this.baseUri) {
    this.baseUri = 'https://localhost:1700/';
  }
  this.appName = appName;
  this.ownerName = ownerName;
  this.buildId = buildId;
  this.branch = branch;
  this.sha = sha;
  this.symbolUploadId = symbolUploadId;
  this.symbolId = symbolId;
  this.crashGroupId = crashGroupId;
  this.crashId = crashId;
  this.start = start;
  this.interval = interval;
  this.credentials = credentials;

  if(options.form !== null && options.form !== undefined) { 
    this.form = options.form;
  }
  if(options.appVersion !== null && options.appVersion !== undefined) { 
    this.appVersion = options.appVersion;
  }
  if(options.dateFrom !== null && options.dateFrom !== undefined) { 
    this.dateFrom = options.dateFrom;
  }
  if(options.dateTo !== null && options.dateTo !== undefined) { 
    this.dateTo = options.dateTo;
  }
  if(options.lastOccurrenceFrom !== null && options.lastOccurrenceFrom !== undefined) { 
    this.lastOccurrenceFrom = options.lastOccurrenceFrom;
  }
  if(options.lastOccurrenceTo !== null && options.lastOccurrenceTo !== undefined) { 
    this.lastOccurrenceTo = options.lastOccurrenceTo;
  }
  if(options.errorType !== null && options.errorType !== undefined) { 
    this.errorType = options.errorType;
  }
  if(options.groupType !== null && options.groupType !== undefined) { 
    this.groupType = options.groupType;
  }
  if(options.groupStatus !== null && options.groupStatus !== undefined) { 
    this.groupStatus = options.groupStatus;
  }
  if(options.includeReport !== null && options.includeReport !== undefined) { 
    this.includeReport = options.includeReport;
  }
  if(options.includeLog !== null && options.includeLog !== undefined) { 
    this.includeLog = options.includeLog;
  }
  if(options.groupTextSearch !== null && options.groupTextSearch !== undefined) { 
    this.groupTextSearch = options.groupTextSearch;
  }
  if(options.end !== null && options.end !== undefined) { 
    this.end = options.end;
  }
  if(options.versions !== null && options.versions !== undefined) { 
    this.versions = options.versions;
  }
  if(options.count !== null && options.count !== undefined) { 
    this.count = options.count;
  }
  if(options.top !== null && options.top !== undefined) { 
    this.top = options.top;
  }
  if(options.skip !== null && options.skip !== undefined) { 
    this.skip = options.skip;
  }
  if(options.filter !== null && options.filter !== undefined) { 
    this.filter = options.filter;
  }
  if(options.inlinecount !== null && options.inlinecount !== undefined) { 
    this.inlinecount = options.inlinecount;
  }
  this.invitations = new operations.Invitations(this);
  this.users = new operations.Users(this);
  this.apps = new operations.Apps(this);
  this.branches = new operations.Branches(this);
  this.builds = new operations.Builds(this);
  this.versionsOperations = new operations.VersionsOperations(this);
  this.sessions = new operations.Sessions(this);
  this.devices = new operations.Devices(this);
  this.available = new operations.Available(this);
  this.apiTokens = new operations.ApiTokens(this);
  this.models = models;
  msRest.addSerializationMixin(this);
}

util.inherits(SonomaClient, ServiceClient);

/**
 * @summary Gets a list of application versions
 *
 * Gets a list of application versions
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getAppVersions = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/versions';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AppVersionElementType',
                  type: {
                    name: 'Composite',
                    className: 'AppVersion'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Return the details for this package.
 *
 * @param {string} packageId The ID of the package
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link PackageDetails} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getPackageInfo = function (packageId, options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (packageId === null || packageId === undefined || typeof packageId.valueOf() !== 'string') {
      throw new Error('packageId cannot be null or undefined and it must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/packages/{package_id}';
  requestUrl = requestUrl.replace('{package_id}', encodeURIComponent(packageId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['PackageDetails']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.crashGroupId] Filter by group. Can be empty
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Segmentation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getHistogramPlatforms = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var crashGroupId = (options && options.crashGroupId !== undefined) ? options.crashGroupId : undefined;
  // Validate
  try {
    if (crashGroupId !== null && crashGroupId !== undefined && typeof crashGroupId.valueOf() !== 'string') {
      throw new Error('crashGroupId must be of type string.');
    }
    if (this.lastOccurrenceFrom && !(this.lastOccurrenceFrom instanceof Date || 
        (typeof this.lastOccurrenceFrom.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceFrom))))) {
          throw new Error('this.lastOccurrenceFrom must be of type date.');
        }
    if (this.lastOccurrenceTo && !(this.lastOccurrenceTo instanceof Date || 
        (typeof this.lastOccurrenceTo.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceTo))))) {
          throw new Error('this.lastOccurrenceTo must be of type date.');
        }
    if (this.errorType !== null && this.errorType !== undefined && typeof this.errorType.valueOf() !== 'string') {
      throw new Error('this.errorType must be of type string.');
    }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.groupStatus !== null && this.groupStatus !== undefined && typeof this.groupStatus.valueOf() !== 'string') {
      throw new Error('this.groupStatus must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_histograms/platforms';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (crashGroupId !== null && crashGroupId !== undefined) {
    queryParameters.push('crash_group_id=' + encodeURIComponent(crashGroupId));
  }
  if (this.lastOccurrenceFrom !== null && this.lastOccurrenceFrom !== undefined) {
    queryParameters.push('last_occurrence_from=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceFrom)));
  }
  if (this.lastOccurrenceTo !== null && this.lastOccurrenceTo !== undefined) {
    queryParameters.push('last_occurrence_to=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceTo)));
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    queryParameters.push('error_type=' + encodeURIComponent(this.errorType));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.groupStatus !== null && this.groupStatus !== undefined) {
    queryParameters.push('group_status=' + encodeURIComponent(this.groupStatus));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Segmentation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.crashGroupId] Filter by group. Can be empty
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Segmentation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getHistogramDevices = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var crashGroupId = (options && options.crashGroupId !== undefined) ? options.crashGroupId : undefined;
  // Validate
  try {
    if (crashGroupId !== null && crashGroupId !== undefined && typeof crashGroupId.valueOf() !== 'string') {
      throw new Error('crashGroupId must be of type string.');
    }
    if (this.lastOccurrenceFrom && !(this.lastOccurrenceFrom instanceof Date || 
        (typeof this.lastOccurrenceFrom.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceFrom))))) {
          throw new Error('this.lastOccurrenceFrom must be of type date.');
        }
    if (this.lastOccurrenceTo && !(this.lastOccurrenceTo instanceof Date || 
        (typeof this.lastOccurrenceTo.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceTo))))) {
          throw new Error('this.lastOccurrenceTo must be of type date.');
        }
    if (this.errorType !== null && this.errorType !== undefined && typeof this.errorType.valueOf() !== 'string') {
      throw new Error('this.errorType must be of type string.');
    }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.groupStatus !== null && this.groupStatus !== undefined && typeof this.groupStatus.valueOf() !== 'string') {
      throw new Error('this.groupStatus must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_histograms/devices';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (crashGroupId !== null && crashGroupId !== undefined) {
    queryParameters.push('crash_group_id=' + encodeURIComponent(crashGroupId));
  }
  if (this.lastOccurrenceFrom !== null && this.lastOccurrenceFrom !== undefined) {
    queryParameters.push('last_occurrence_from=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceFrom)));
  }
  if (this.lastOccurrenceTo !== null && this.lastOccurrenceTo !== undefined) {
    queryParameters.push('last_occurrence_to=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceTo)));
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    queryParameters.push('error_type=' + encodeURIComponent(this.errorType));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.groupStatus !== null && this.groupStatus !== undefined) {
    queryParameters.push('group_status=' + encodeURIComponent(this.groupStatus));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Segmentation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Crash Histogram. Returns the total number of crashes.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.crashGroupId] Filter by group. Can be empty
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Histogram} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getHistogramCrashes = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var crashGroupId = (options && options.crashGroupId !== undefined) ? options.crashGroupId : undefined;
  // Validate
  try {
    if (crashGroupId !== null && crashGroupId !== undefined && typeof crashGroupId.valueOf() !== 'string') {
      throw new Error('crashGroupId must be of type string.');
    }
    if (this.lastOccurrenceFrom && !(this.lastOccurrenceFrom instanceof Date || 
        (typeof this.lastOccurrenceFrom.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceFrom))))) {
          throw new Error('this.lastOccurrenceFrom must be of type date.');
        }
    if (this.lastOccurrenceTo && !(this.lastOccurrenceTo instanceof Date || 
        (typeof this.lastOccurrenceTo.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceTo))))) {
          throw new Error('this.lastOccurrenceTo must be of type date.');
        }
    if (this.errorType !== null && this.errorType !== undefined && typeof this.errorType.valueOf() !== 'string') {
      throw new Error('this.errorType must be of type string.');
    }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.groupStatus !== null && this.groupStatus !== undefined && typeof this.groupStatus.valueOf() !== 'string') {
      throw new Error('this.groupStatus must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_histograms/crashes';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (crashGroupId !== null && crashGroupId !== undefined) {
    queryParameters.push('crash_group_id=' + encodeURIComponent(crashGroupId));
  }
  if (this.lastOccurrenceFrom !== null && this.lastOccurrenceFrom !== undefined) {
    queryParameters.push('last_occurrence_from=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceFrom)));
  }
  if (this.lastOccurrenceTo !== null && this.lastOccurrenceTo !== undefined) {
    queryParameters.push('last_occurrence_to=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceTo)));
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    queryParameters.push('error_type=' + encodeURIComponent(this.errorType));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.groupStatus !== null && this.groupStatus !== undefined) {
    queryParameters.push('group_status=' + encodeURIComponent(this.groupStatus));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Histogram']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.crashGroupId] Filter by group. Can be empty
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Histogram} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getHistogramCrashFreeUsers = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var crashGroupId = (options && options.crashGroupId !== undefined) ? options.crashGroupId : undefined;
  // Validate
  try {
    if (crashGroupId !== null && crashGroupId !== undefined && typeof crashGroupId.valueOf() !== 'string') {
      throw new Error('crashGroupId must be of type string.');
    }
    if (this.lastOccurrenceFrom && !(this.lastOccurrenceFrom instanceof Date || 
        (typeof this.lastOccurrenceFrom.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceFrom))))) {
          throw new Error('this.lastOccurrenceFrom must be of type date.');
        }
    if (this.lastOccurrenceTo && !(this.lastOccurrenceTo instanceof Date || 
        (typeof this.lastOccurrenceTo.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceTo))))) {
          throw new Error('this.lastOccurrenceTo must be of type date.');
        }
    if (this.errorType !== null && this.errorType !== undefined && typeof this.errorType.valueOf() !== 'string') {
      throw new Error('this.errorType must be of type string.');
    }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.groupStatus !== null && this.groupStatus !== undefined && typeof this.groupStatus.valueOf() !== 'string') {
      throw new Error('this.groupStatus must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_histograms/crash_free_users';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (crashGroupId !== null && crashGroupId !== undefined) {
    queryParameters.push('crash_group_id=' + encodeURIComponent(crashGroupId));
  }
  if (this.lastOccurrenceFrom !== null && this.lastOccurrenceFrom !== undefined) {
    queryParameters.push('last_occurrence_from=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceFrom)));
  }
  if (this.lastOccurrenceTo !== null && this.lastOccurrenceTo !== undefined) {
    queryParameters.push('last_occurrence_to=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceTo)));
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    queryParameters.push('error_type=' + encodeURIComponent(this.errorType));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.groupStatus !== null && this.groupStatus !== undefined) {
    queryParameters.push('group_status=' + encodeURIComponent(this.groupStatus));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Histogram']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets a stacktrace for a specific error
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Stacktrace} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getGroupStacktrace = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/stacktrace';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Stacktrace']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets a stacktrace for a specific error
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Stacktrace} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getErrorStacktrace = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.crashId === null || this.crashId === undefined || typeof this.crashId.valueOf() !== 'string') {
      throw new Error('this.crashId cannot be null or undefined and it must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/stacktrace';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{crash_id}', encodeURIComponent(this.crashId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Stacktrace']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets a specific error for an app
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link Crash} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getCrash = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.crashId === null || this.crashId === undefined || typeof this.crashId.valueOf() !== 'string') {
      throw new Error('this.crashId cannot be null or undefined and it must be of type string.');
    }
    if (this.includeReport !== null && this.includeReport !== undefined && typeof this.includeReport !== 'boolean') {
      throw new Error('this.includeReport must be of type boolean.');
    }
    if (this.includeLog !== null && this.includeLog !== undefined && typeof this.includeLog !== 'boolean') {
      throw new Error('this.includeLog must be of type boolean.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{crash_id}', encodeURIComponent(this.crashId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (this.includeReport !== null && this.includeReport !== undefined) {
    queryParameters.push('include_report=' + encodeURIComponent(this.includeReport.toString()));
  }
  if (this.includeLog !== null && this.includeLog !== undefined) {
    queryParameters.push('include_log=' + encodeURIComponent(this.includeLog.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 201) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['Crash']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets all crashes of the app
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getCrashes = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.includeReport !== null && this.includeReport !== undefined && typeof this.includeReport !== 'boolean') {
      throw new Error('this.includeReport must be of type boolean.');
    }
    if (this.includeLog !== null && this.includeLog !== undefined && typeof this.includeLog !== 'boolean') {
      throw new Error('this.includeLog must be of type boolean.');
    }
    if (this.dateFrom && !(this.dateFrom instanceof Date || 
        (typeof this.dateFrom.valueOf() === 'string' && !isNaN(Date.parse(this.dateFrom))))) {
          throw new Error('this.dateFrom must be of type date.');
        }
    if (this.dateTo && !(this.dateTo instanceof Date || 
        (typeof this.dateTo.valueOf() === 'string' && !isNaN(Date.parse(this.dateTo))))) {
          throw new Error('this.dateTo must be of type date.');
        }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.errorType !== null && this.errorType !== undefined && typeof this.errorType.valueOf() !== 'string') {
      throw new Error('this.errorType must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (this.includeReport !== null && this.includeReport !== undefined) {
    queryParameters.push('include_report=' + encodeURIComponent(this.includeReport.toString()));
  }
  if (this.includeLog !== null && this.includeLog !== undefined) {
    queryParameters.push('include_log=' + encodeURIComponent(this.includeLog.toString()));
  }
  if (this.dateFrom !== null && this.dateFrom !== undefined) {
    queryParameters.push('date_from=' + encodeURIComponent(client.serializeObject(this.dateFrom)));
  }
  if (this.dateTo !== null && this.dateTo !== undefined) {
    queryParameters.push('date_to=' + encodeURIComponent(client.serializeObject(this.dateTo)));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.errorType !== null && this.errorType !== undefined) {
    queryParameters.push('error_type=' + encodeURIComponent(this.errorType));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'CrashElementType',
                  type: {
                    name: 'Composite',
                    className: 'Crash'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets a specific group
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CrashGroup} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getCrashGroup = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CrashGroup']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Updates a group
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.status] Possible values include: 'Open', 'Closed',
 * 'Ignored'
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CrashGroup} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.patchCrashGroup = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var status = (options && options.status !== undefined) ? options.status : undefined;
  // Validate
  try {
    if (this.crashGroupId === null || this.crashGroupId === undefined || typeof this.crashGroupId.valueOf() !== 'string') {
      throw new Error('this.crashGroupId cannot be null or undefined and it must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
    if (status !== null && status !== undefined && typeof status.valueOf() !== 'string') {
      throw new Error('status must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var group;
  if (status !== null && status !== undefined) {
      group = new client.models['CrashGroupChange']();
      group.status = status;
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}';
  requestUrl = requestUrl.replace('{crash_group_id}', encodeURIComponent(this.crashGroupId));
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (group !== null && group !== undefined) {
      var requestModelMapper = new client.models['CrashGroupChange']().mapper();
      requestModel = client.serialize(requestModelMapper, group, 'group');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(group, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CrashGroup']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Gets a list of crashes
 *
 * Gets a list of crashes
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
SonomaClient.prototype.getCrashGroups = function (options, callback) {
  var client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.lastOccurrenceFrom && !(this.lastOccurrenceFrom instanceof Date || 
        (typeof this.lastOccurrenceFrom.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceFrom))))) {
          throw new Error('this.lastOccurrenceFrom must be of type date.');
        }
    if (this.lastOccurrenceTo && !(this.lastOccurrenceTo instanceof Date || 
        (typeof this.lastOccurrenceTo.valueOf() === 'string' && !isNaN(Date.parse(this.lastOccurrenceTo))))) {
          throw new Error('this.lastOccurrenceTo must be of type date.');
        }
    if (this.appVersion !== null && this.appVersion !== undefined && typeof this.appVersion.valueOf() !== 'string') {
      throw new Error('this.appVersion must be of type string.');
    }
    if (this.groupType !== null && this.groupType !== undefined && typeof this.groupType.valueOf() !== 'string') {
      throw new Error('this.groupType must be of type string.');
    }
    if (this.groupStatus !== null && this.groupStatus !== undefined && typeof this.groupStatus.valueOf() !== 'string') {
      throw new Error('this.groupStatus must be of type string.');
    }
    if (this.groupTextSearch !== null && this.groupTextSearch !== undefined && typeof this.groupTextSearch.valueOf() !== 'string') {
      throw new Error('this.groupTextSearch must be of type string.');
    }
    if (this.ownerName === null || this.ownerName === undefined || typeof this.ownerName.valueOf() !== 'string') {
      throw new Error('this.ownerName cannot be null or undefined and it must be of type string.');
    }
    if (this.appName === null || this.appName === undefined || typeof this.appName.valueOf() !== 'string') {
      throw new Error('this.appName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.baseUri +
                   '//v0.1/apps/{owner_name}/{app_name}/crash_groups';
  requestUrl = requestUrl.replace('{owner_name}', encodeURIComponent(this.ownerName));
  requestUrl = requestUrl.replace('{app_name}', encodeURIComponent(this.appName));
  var queryParameters = [];
  if (this.lastOccurrenceFrom !== null && this.lastOccurrenceFrom !== undefined) {
    queryParameters.push('last_occurrence_from=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceFrom)));
  }
  if (this.lastOccurrenceTo !== null && this.lastOccurrenceTo !== undefined) {
    queryParameters.push('last_occurrence_to=' + encodeURIComponent(client.serializeObject(this.lastOccurrenceTo)));
  }
  if (this.appVersion !== null && this.appVersion !== undefined) {
    queryParameters.push('app_version=' + encodeURIComponent(this.appVersion));
  }
  if (this.groupType !== null && this.groupType !== undefined) {
    queryParameters.push('group_type=' + encodeURIComponent(this.groupType));
  }
  if (this.groupStatus !== null && this.groupStatus !== undefined) {
    queryParameters.push('group_status=' + encodeURIComponent(this.groupStatus));
  }
  if (this.groupTextSearch !== null && this.groupTextSearch !== undefined) {
    queryParameters.push('group_text_search=' + encodeURIComponent(this.groupTextSearch));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['Failure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'CrashGroupElementType',
                  type: {
                    name: 'Composite',
                    className: 'CrashGroup'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

module.exports = SonomaClient;
